# CRITICAL PROJECT DEVELOPMENT RULES
**These rules are absolutely mandatory and must be referenced for all development work!**

## CRITICAL SUMMARY (Zero Tolerance)
- Absolutely NO emojis in code, documentation, or comments
- English-only for all artifacts (code, comments, documentation, commit messages)
- Absolutely NO hardcoding of domain/schema names (entities, fields, tables, enums, methods, columns)
- Do not generate debug logs unless explicitly requested
- Do not add defensive logic for uncertain situations
- Do not write retry logic for uncertain states

## General Development Rules

### Code Style Guidelines
- Do not add comments to indicate changes from previous code versions
- Find and solve the actual root cause; do not insert defensive logic
- Do not change the specified implementation approach unless explicitly instructed
- Do not write fallback or backup functionality except when errors are unavoidable

### Language and Internationalization
- All program artifacts must be written in English (code, comments, documentation, commit messages)
- Handle error messages and user-facing text via the i18n system

### Naming and Comments
- Use clear, descriptive English variable and function names
- Avoid abbreviations unless they are widely accepted standards
- Write concise comments for complex logic; use proper grammar and punctuation

### Git Commit Messages
- ALL commit messages MUST be written in English
- Use the conventional commit format: feat:, fix:, docs:, refactor:, test:, etc.
- Be clear and descriptive about what changed and why

### Development Workflow
- Do not perform git commit/push operations unless explicitly requested
- When the same problem occurs more than twice, consult official documentation
- File Size Management: If a file exceeds 500 lines, prioritize refactoring and propose solutions
- Refactoring Safety: Ensure no duplicate functionality remains; fully remove obsolete code

## Java/Spring Specific Guidelines

### Core Principles
- Follow Java naming conventions (PascalCase for classes, camelCase for methods/variables)
- Follow Spring Boot best practices and conventions
- Implement proper exception handling with meaningful messages
- Use Spring Data JPA repositories for database operations
- Follow RESTful API design principles
- Use Bean Validation annotations for input validation
- Use Spring Security for authentication and authorization
- Follow Spring Boot configuration management best practices

### Zero Hardcoding Policy
ABSOLUTE PROHIBITION OF HARDCODING — NO EXCEPTIONS — VIOLATIONS WILL BE REJECTED

#### Strictly Forbidden Hardcoding
- Entity names (e.g., "TestPost", "User", "Order")
- Field names (e.g., "id", "name", "status")
- Database column names (e.g., "user_id", "created_at")
- Table names (e.g., "test_post", "user_table")
- Enum values (e.g., "PUBLISHED", "ACTIVE")
- Method names (e.g., "getId", "getName")
- Property names in configuration or mapping
- Any specific JPA entity or schema details

#### Enforcement
- Immediate rejection of code containing hardcoded names or schema details
- Zero tolerance for "temporary" or "convenience" hardcoding
- Dynamic-first: implement dynamic solutions from the start
- Tests must cover multiple entity types

## Testing Guidelines

### General
- Write unit tests for business logic
- Write integration tests for Spring components
- Use JUnit 5 and Mockito
- Co-locate tests with the code they test

### Dynamic Implementations
- Test with multiple entity types; avoid assumptions tied to specific entities
- Include entities with simple IDs, composite IDs, and diverse field types
- Ensure performance is acceptable; dynamic approaches must not degrade it significantly
- NEVER modify test conditions or add hardcoding to make tests pass; seek feedback if tests are wrong
- Solve one problem at a time systematically

## Performance Considerations
- Use Spring Boot's performance monitoring
- Optimize database queries and indexes
- Apply caching strategies when appropriate
- Monitor and review application performance metrics

## Documentation Guidelines
- Do not create new documentation files unless explicitly requested
- Maintain existing documentation only when specifically asked
- Prefer concise inline comments for complex logic over separate docs

## Examples and Guidelines

### Examples of Good Commit Messages
- "feat: add dynamic ID field detection to CursorCalculator"
- "fix: remove hardcoded TestPost entity references"
- "refactor: replace hardcoded field names with JPA metamodel"
- "test: add dynamic entity testing for multiple entity types"
- "docs: update README with dynamic implementation guidelines"
