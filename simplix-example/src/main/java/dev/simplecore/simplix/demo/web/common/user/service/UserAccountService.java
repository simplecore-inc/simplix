package dev.simplecore.simplix.demo.web.common.user.service;

import dev.simplecore.simplix.demo.permission.CustomUserDetailsService;
import dev.simplecore.simplix.demo.web.common.user.dto.UserAccountDTOs.*;
import dev.simplecore.simplix.demo.domain.common.user.entity.UserAccount;
import dev.simplecore.simplix.demo.domain.common.user.repository.UserAccountRepository;
import dev.simplecore.simplix.demo.web.common.user.excel.UserAccountListExcel;
import dev.simplecore.simplix.web.service.SimpliXBaseService;
import com.github.thkwag.searchable.core.condition.SearchCondition;
import com.github.thkwag.searchable.core.condition.parser.SearchableParamsParser;

import org.springframework.beans.factory.ObjectProvider;
import org.springframework.data.domain.Page;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.persistence.EntityManager;
import java.util.*;

/**
 * This file was auto-generated by SimpliX Generator
 * 
 * Generator Version: 0.0.1
 * Generated At: 2025-02-04T15:58:41.833+09:00
 * Generated By: thkwag<thkwag@gmail.com>
 */

/**
 * Service class for managing UserAccount entities.
 * Provides business logic for CRUD operations, batch processing, and search functionality for UserAccount entities.
 */
@Service
@Transactional(readOnly = true)
public class UserAccountService extends SimpliXBaseService<UserAccount, String> {
    
    private final ObjectProvider<UserPositionService> userPositionServiceProvider;
    
    private final ObjectProvider<UserRoleService> userRoleServiceProvider;
    
    private final ObjectProvider<UserOrganizationService> userOrganizationServiceProvider;

    private final ObjectProvider<CustomUserDetailsService> userDetailsServiceProvider;

    /**
     * Constructs a new UserAccountService with required dependencies.
     *
     * @param repository The repository for UserAccount entities
     * @param entityManager JPA EntityManager for database operations
     * @param userPositionServiceProvider Provider for UserPosition service
     * @param userRoleServiceProvider Provider for UserRole service
     * @param userOrganizationServiceProvider Provider for UserOrganization service
     * @param userDetailsServiceProvider Provider for CustomUserDetailsService
     */
    public UserAccountService(
        UserAccountRepository repository,
        EntityManager entityManager,
        ObjectProvider<UserPositionService> userPositionServiceProvider,
        ObjectProvider<UserRoleService> userRoleServiceProvider,
        ObjectProvider<UserOrganizationService> userOrganizationServiceProvider,
        ObjectProvider<CustomUserDetailsService> userDetailsServiceProvider
    ) {
        super(repository, entityManager);
        

        this.userPositionServiceProvider = userPositionServiceProvider;
        this.userRoleServiceProvider = userRoleServiceProvider;
        this.userOrganizationServiceProvider = userOrganizationServiceProvider;
        this.userDetailsServiceProvider = userDetailsServiceProvider;

    }

    /**
     * Creates a new UserAccount entity from the provided DTO.
     *
     * @param createDTO DTO containing the data for the new UserAccount
     * @return UserAccountDetailDTO of the created entity
     * @throws RuntimeException if related entities are not found
     */
    @Transactional
    public UserAccountDetailDTO create(UserAccountCreateDTO createDTO) {
        UserAccount entity = modelMapper.map(createDTO, UserAccount.class);
        return saveAndGetProjection(entity, createDTO.getPosition(), createDTO.getRoles(), createDTO.getOrganizations());
    }

    /**
     * Updates an existing UserAccount entity with the provided DTO data.
     *
     * @param entity The existing UserAccount entity to update
     * @param updateDto DTO containing the updated data
     * @return UserAccountDetailDTO of the updated entity
     * @throws RuntimeException if related entities are not found
     */
    @Transactional
    public UserAccountDetailDTO update(UserAccount entity, UserAccountUpdateDTO updateDto) {
        modelMapper.map(updateDto, entity);
        UserAccountDetailDTO result = saveAndGetProjection(entity, updateDto.getPosition(), updateDto.getRoles(), updateDto.getOrganizations());
        
        // Update current authentication if it's the same user
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.getName().equals(entity.getUsername())) {
            userDetailsServiceProvider.getIfAvailable().updateAuthenticationPrincipal(entity.getUsername());
        }
        
        return result;
    }

    /**
     * Deletes a UserAccount entity by its ID.
     *
     * @param id The ID of the UserAccount to delete
     */
    @Transactional
    public void delete(String id) {
        deleteById(id);
    }

    /**
     * Deletes multiple UserAccount entities by their IDs.
     *
     * @param ids List of UserAccount IDs to delete
     */
    @Transactional
    public void batchDelete(List<String> ids) {
        deleteAllByIds(ids);
    }

    /**
     * Searches for UserAccount entities using provided search parameters.
     *
     * @param params Map of search parameters and their values
     * @return Page of UserAccountListDTO matching the search criteria
     */
    public Page<UserAccountListDTO> search(Map<String, String> params) {
        SearchCondition<UserAccountSearchDTO> searchCondition =
                new SearchableParamsParser<UserAccountSearchDTO>(UserAccountSearchDTO.class).convert(params);
        return findAllWithSearch(searchCondition, UserAccountListDTO.class);
    }

    /**
     * Searches for UserAccount entities using a SearchCondition object.
     *
     * @param searchCondition Search conditions for filtering UserAccount entities
     * @return Page of UserAccountListDTO matching the search criteria
     */
    public Page<UserAccountListDTO> search(SearchCondition<UserAccountSearchDTO> searchCondition) {
        return findAllWithSearch(searchCondition, UserAccountListDTO.class);
    }

    /**
     * Excel 내보내기를 위해 UserAccountListDTO를 UserAccountListExcel로 변환하여 반환
     *
     * @param searchCondition Search conditions for filtering UserAccount entities
     * @return UserAccountListDTO를 UserAccountListExcel로 변환한 목록
     */
    public List<UserAccountListExcel> searchForExcel(SearchCondition<UserAccountSearchDTO> searchCondition) {
        Page<UserAccount> page = findAllWithSearch(searchCondition);
        
        // UserAccountListDTO를 UserAccountListExcel로 변환
        return page.getContent().stream()
            .map(UserAccountListExcel::from)
            .collect(java.util.stream.Collectors.toList());
    }

    /**
     * Updates multiple UserAccount entities in a single operation.
     *
     * @param updateDtos Set of DTOs containing update data for multiple UserAccounts
     * @return List of UserAccountDetailDTO for the updated entities
     * @throws RuntimeException if any related entities are not found
     */
    @Transactional
    public List<UserAccountDetailDTO> multiUpdate(Set<UserAccountUpdateDTO> updateDtos) {
        List<UserAccountDetailDTO> updatedEntities = new ArrayList<>();
        
        for (UserAccountUpdateDTO updateDto : updateDtos) {
            if (updateDto.getId() == null) {
                continue;
            }

            Optional<UserAccount> entityOpt = findById(updateDto.getId());
            if (entityOpt.isPresent()) {
                UserAccount entity = entityOpt.get();
                UserAccountDetailDTO updatedEntity = update(entity, updateDto);
                updatedEntities.add(updatedEntity);
            }
        }
        
        return updatedEntities;
    }

    /**
     * Performs batch updates on multiple UserAccount entities.
     *
     * @param dto DTO containing the batch update data and target IDs
     * @throws RuntimeException if any related entities are not found
     */
    @Transactional
    public void batchUpdate(UserAccountBatchUpdateDTO dto) {
        List<UserAccount> entities = findAllById(dto.getIds());
        
        entities.forEach(entity -> {
            
            if (dto.getEnabled() != null) {
                entity.setEnabled(dto.getEnabled());
            }
            
            if (dto.getPosition() != null) {
                Objects.requireNonNull(userPositionServiceProvider.getIfAvailable()).findById(dto.getPosition())
                    .ifPresent(entity::setPosition);
            }
            
            if (dto.getRoles() != null) {
                entity.setRoles(new HashSet<>(
                    Objects.requireNonNull(userRoleServiceProvider.getIfAvailable()).findAllById(dto.getRoles())
                ));
            }
            
            if (dto.getOrganizations() != null) {
                entity.setOrganizations(new HashSet<>(
                    Objects.requireNonNull(userOrganizationServiceProvider.getIfAvailable()).findAllById(dto.getOrganizations())
                ));
            }
        });

        saveAll(entities);
    }

    //----------------------------------

    /**
     * Saves a UserAccount entity and returns its projection.
     * Handles the relationships with other entities.
     *
     * @param entity The UserAccount entity to save
     * @param dto The DTO containing relationship data
     * @return UserAccountDetailDTO of the saved entity
     * @throws RuntimeException if saving fails or if related entities are not found
     */
    private UserAccountDetailDTO saveAndGetProjection(UserAccount entity, String position, Set<String> roles, Set<String> organizations) {
        //----------------------------------
        // Many-to-one relationships
        //----------------------------------
        
        // UserPosition
        if (position != null) {
            UserPositionService userPositionService = userPositionServiceProvider.getIfAvailable();
            if (userPositionService != null) {
                entity.setPosition(userPositionService.findById(position)
                    .orElseThrow(() -> new RuntimeException("UserPosition not found")));
            }
        }
                

        //----------------------------------
        // Many-to-many relationships
        //----------------------------------
        
        // UserRole
        if (roles != null) {
            UserRoleService userRoleService = userRoleServiceProvider.getIfAvailable();
            if (userRoleService != null) {
                entity.setRoles(new HashSet<>(userRoleService.findAllById(roles)));
            }
        }
                
        // UserOrganization
        if (organizations != null) {
            UserOrganizationService userOrganizationService = userOrganizationServiceProvider.getIfAvailable();
            if (userOrganizationService != null) {
                entity.setOrganizations(new HashSet<>(userOrganizationService.findAllById(organizations)));
            }
        }
        
        UserAccount savedEntity = saveAndFlush(entity);

        return findById(savedEntity.getId(), UserAccountDetailDTO.class)
            .orElseThrow(() -> new RuntimeException("Failed to retrieve saved entity"));
    }

    @Override
    public boolean hasOwnerPermission(String permission, String id, Object dto) {
        UserAccount entity = new UserAccount();
        if (id != null) {
            entity = findById(id).orElseThrow(() -> new RuntimeException("UserAccount not found"));
        } else {
            modelMapper.map(dto, entity);
        }

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (new HashSet<>(Arrays.asList("view", "edit")).contains(permission)) {
            return auth.getName().equals(entity.getUsername());
        }

        return false;
    }
} 