package dev.simplecore.simplix.demo.web.common.user.service;

import dev.simplecore.searchable.core.condition.SearchCondition;
import dev.simplecore.searchable.core.condition.parser.SearchableParamsParser;
import dev.simplecore.simplix.demo.domain.common.user.entity.UserAccountLog;
import dev.simplecore.simplix.demo.domain.common.user.entity.UserAccountLog.UserAccountLogId;
import dev.simplecore.simplix.demo.domain.common.user.repository.UserAccountLogRepository;
import dev.simplecore.simplix.demo.web.common.user.dto.UserAccountLogDTOs.*;
import dev.simplecore.simplix.web.service.SimpliXBaseService;
import org.springframework.data.domain.Page;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import jakarta.persistence.EntityManager;
import java.util.*;

/**
 * This file was auto-generated by SimpliX Generator
 *
 * Generator Version: 0.0.1
 * Generated At: 2025-04-27T19:16:32.131+09:00
 * Generated By: Taehwan Kwag<thkwag@gmail.com>
 */

/**
 * Service class for managing UserAccountLog entities.
 * Provides business logic for CRUD operations, batch processing, and search functionality for UserAccountLog entities.

 * This entity uses a composite key (UserAccountLogId).

 */
@Service
@Transactional(readOnly = true)
public class UserAccountLogService extends SimpliXBaseService<UserAccountLog, UserAccountLogId> {

    /**
     * Constructs a new UserAccountLogService with required dependencies.
     *
     * @param repository The repository for UserAccountLog entities
     * @param entityManager JPA EntityManager for database operations
     */
    public UserAccountLogService(
        UserAccountLogRepository repository,
        EntityManager entityManager
    ) {
        super(repository, entityManager);
        
    }

    /**
     * Creates a new UserAccountLog entity from the provided DTO.
     *
     * @param createDTO DTO containing the data for the new UserAccountLog
     * @return UserAccountLogDetailDTO of the created entity
     * @throws RuntimeException if related entities are not found
     */
    @Transactional
    public UserAccountLogDetailDTO create(UserAccountLogCreateDTO createDTO) {
        UserAccountLog entity = new UserAccountLog();
        modelMapper.map(createDTO, entity);
        return saveAndGetProjection(entity);
    }

    /**
     * Updates an existing UserAccountLog entity with the provided DTO data.
     *
     * @param entity The existing UserAccountLog entity to update
     * @param updateDto DTO containing the updated data
     * @return UserAccountLogDetailDTO of the updated entity
     * @throws RuntimeException if related entities are not found
     */
    @Transactional
    public UserAccountLogDetailDTO update(UserAccountLog entity, UserAccountLogUpdateDTO updateDto) {
        modelMapper.map(updateDto, entity);
        return saveAndGetProjection(entity);
    }

    /**
     * Deletes a UserAccountLog entity by its ID.
     *
     * @param id The ID of the UserAccountLog to delete
     */
    @Transactional
    public void delete(UserAccountLogId id) {
        deleteById(id);
    }

    /**
     * Deletes multiple UserAccountLog entities by their IDs.
     *
     * @param ids List of UserAccountLog IDs to delete
     */
    @Transactional
    public void batchDelete(List<UserAccountLogId> ids) {
        deleteAllByIds(ids);
    }

    /**
     * Searches for UserAccountLog entities using provided search parameters.
     *
     * @param params Map of search parameters and their values
     * @return Page of UserAccountLogListDTO matching the search criteria
     */
    public Page<UserAccountLogListDTO> search(Map<String, String> params) {
        SearchCondition<UserAccountLogSearchDTO> searchCondition =
                new SearchableParamsParser<UserAccountLogSearchDTO>(UserAccountLogSearchDTO.class).convert(params);
        return findAllWithSearch(searchCondition, UserAccountLogListDTO.class);
    }

    /**
     * Searches for UserAccountLog entities using a SearchCondition object.
     *
     * @param searchCondition Search conditions for filtering UserAccountLog entities
     * @return Page of UserAccountLogListDTO matching the search criteria
     */
    public Page<UserAccountLogListDTO> search(SearchCondition<UserAccountLogSearchDTO> searchCondition) {
        return findAllWithSearch(searchCondition, UserAccountLogListDTO.class);
    }

    /**
     * Updates multiple UserAccountLog entities in a single operation.
     *
     * @param updateDtos Set of DTOs containing update data for multiple UserAccountLogs
     * @return List of UserAccountLogDetailDTO for the updated entities
     * @throws RuntimeException if any related entities are not found
     */
    @Transactional
    public List<UserAccountLogDetailDTO> multiUpdate(Set<UserAccountLogUpdateDTO> updateDtos) {
        List<UserAccountLogDetailDTO> updatedEntities = new ArrayList<>();

        for (UserAccountLogUpdateDTO updateDto : updateDtos) {
            if (updateDto.getId() == null) {
                continue;
            }

            Optional<UserAccountLog> entityOpt = findById(updateDto.getId());
            if (entityOpt.isPresent()) {
                UserAccountLog entity = entityOpt.get();
                UserAccountLogDetailDTO updatedEntity = update(entity, updateDto);
                updatedEntities.add(updatedEntity);
            }
        }

        return updatedEntities;
    }

    /**
     * Performs batch updates on multiple UserAccountLog entities.
     *
     * @param dto DTO containing the batch update data and target IDs
     * @throws RuntimeException if any related entities are not found
     */
    @Transactional
    public void batchUpdate(UserAccountLogBatchUpdateDTO dto) {
        List<UserAccountLog> entities = findAllById(dto.getIds());

        entities.forEach(entity -> {
            
            if (dto.getLogMessage() != null) {
                entity.setLogMessage(dto.getLogMessage());
            }
            
        });

        saveAll(entities);
    }

    //----------------------------------

    /**
     * Saves a UserAccountLog entity and returns its projection.
     * Handles the relationships with other entities.
     *
     * @param entity The UserAccountLog entity to save
     * @param dto The DTO containing relationship data
     * @return UserAccountLogDetailDTO of the saved entity
     * @throws RuntimeException if saving fails or if related entities are not found
     */
    private UserAccountLogDetailDTO saveAndGetProjection(UserAccountLog entity) {

        UserAccountLog savedEntity = saveAndFlush(entity);
        return findById(savedEntity.getId(), UserAccountLogDetailDTO.class)
            .orElseThrow(() -> new RuntimeException("Failed to retrieve saved entity"));
    }

    //----------------------------------

    /**
     * Checks if the current user has the specified permission for the entity.
     *
     * @param permission The permission to check (e.g., "view", "edit", "delete")
     * @param id The ID of the entity to check permissions for. Can be null for new entities
     * @param dto The DTO object containing entity data. Used when id is null
     * @return true if the user has the permission, false otherwise
     * @throws RuntimeException if the entity is not found with the given id
     */
    @Override
    public boolean hasOwnerPermission(String permission, UserAccountLogId id, Object dto) {
        // TODO must be implemented

        // // Example implementation
        // UserAccountLog entity = new UserAccountLog();
        // if (id != null) {
        //     entity = findById(id).orElseThrow(() -> new RuntimeException("UserAccountLog not found"));
        // } else {
        //     modelMapper.map(dto, entity);
        // }

        // Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        // if (Set.of("view", "edit", "delete").contains(permission)) {
        //     return auth.getName().equals(entity.getUsername());
        // }

        throw new UnsupportedOperationException("Unimplemented method 'hasPermission'");
    }
}
