package <%= packagePaths['dto'] %>;

<% if (hasEmbeddedId) { %>
import <%= entityPackage %>.<%= entityName %>.<%= embeddedIdType %>;
<% } %>

<%
// 참조 엔티티의 import 구문 분석
const importedTypes = new Set();

// 엔티티 필드에서 참조 타입 찾기
fields.forEach(field => {
    if (field.typeKind === 'entity' || field.isRelation || field.relationType === 'ManyToOne') {
        const entityType = field.isCollection ? field.actualType : field.type;
        const entityImport = field.importPath || `${entityPackage}.${entityType}`;
        if (!importedTypes.has(entityType)) {
            importedTypes.add(entityType); %>
import <%= entityImport %>;<%
        }
    }
    // enum 타입 처리
    else if (field.typeKind === 'enum') {
        const enumImport = field.importPath || `${basePackage}.enums.${field.type}`;
        if (!importedTypes.has(field.type)) {
            importedTypes.add(field.type); %>
import <%= enumImport %>;<%
        }
    }
}); %>
import java.util.*;
import java.time.*;
import java.math.*;
import dev.simplecore.searchable.core.annotation.SearchableField;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import org.springframework.format.annotation.DateTimeFormat;
import jakarta.validation.constraints.*;

import static dev.simplecore.searchable.core.condition.operator.SearchOperator.*;

/**
 * This file was auto-generated by SimpliX Generator
 * 
 * Generator Version: <%= generatorVersion %>
 * Generated At: <%= generatedAt %>
 * Generated By: <%= gitUser %><<%= gitEmail %>>
 */
public class <%= entityName %>DTOs {

    //----------------------------------
    // Search
    //----------------------------------

    @Getter
    @Setter
    public static class <%= entityName %>SearchDTO {
        <% if (hasEmbeddedId) { 
            if (embeddedIdSearchFields && embeddedIdSearchFields.length > 0) {
                embeddedIdSearchFields.forEach(field => { %>
        @Schema(description = "<%= field.comment %>")
        @SearchableField(entityField = "<%= field.entityField %>", operators = {<%= field.operators %>}<% if (field.sortable) { %>, sortable = true<% } %>)
        private <%= field.type %> <%= field.name %>;
                <% });
            }
        } else { 
            const idFieldInfo = entitySearchFields.find(f => f.name === ymlConfig.idField); %>
        @Schema(description = "<%= idFieldInfo?.comment || `${entityName} ID` %>")
        @SearchableField(<% if (idFieldInfo?.entityField) { %>entityField = "<%= idFieldInfo.entityField %>", <% } %>operators = {<%= idFieldInfo?.operators || 'EQUALS' %>}<% if (idFieldInfo?.sortable) { %>, sortable = true<% } %>)
        private <%= idFieldInfo?.type || idType %> <%= ymlConfig.idField %>;
        <% } %>
        <% if (entitySearchFields && entitySearchFields.length > 0) {
            entitySearchFields
                .filter(field => field.name !== ymlConfig.idField && !hasEmbeddedId)
                .forEach(field => { %>
        @Schema(description = "<%= field.comment %>")
        @SearchableField(<% if (field.entityField) { %>entityField = "<%= field.entityField %>", <% } %>operators = {<%= field.operators %>}<% if (field.sortable) { %>, sortable = true<% } %>)
        private <%= field.type %> <%= field.name %>;
            <% });
        } %>
        
        //----------

        @Schema(description = "Created by")
        private String createdBy;

        @Schema(description = "Created at")
        @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm")
        private OffsetDateTime createdAt;

        @Schema(description = "Updated by")
        private String updatedBy;

        @Schema(description = "Updated at")
        @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm")
        private OffsetDateTime updatedAt;
    }

    //----------------------------------
    // Create, Update
    //----------------------------------

    @Data
    public static class <%= entityName %>CreateDTO {
        <% if (hasEmbeddedId) { %>
        <% const idFieldConfig = ymlConfig.fields[ymlConfig.idField]; %>
        <% } %>
        <% 
        for (let field of entityFields) { 
            const ymlField = ymlConfig.fields[field.name];
            if (ymlField?.views?.includes('edit') && field.name !== ymlConfig.idField) { 
              let fieldType = field.type;
              let fieldName = field.name;
              let comment = field.comment ? field.comment.split(':')[0] : ymlField.comment || fieldName;
              
              // 참조 필드인 경우
              if (ymlField?.reference) {
                const collectionType = ymlField.reference.multiple ? 'Set' : null;
                fieldType = collectionType 
                  ? `${collectionType}<${ymlField.reference.idType || 'String'}>`
                  : ymlField.reference.idType || 'String';
                fieldName = ymlField.reference.multiple
                  ? `${ymlField.reference.idField}s`
                  : ymlField.reference.idField;
                comment = `${comment} ID`;
              }
              // 컬렉션 필드인 경우
              else if (field.isCollection) {
                if (field.collectionType === 'Map') {
                  fieldType = field.type;  // Map<String, String> 형태의 원본 타입 사용
                } else {
                  fieldType = `${field.collectionType || 'List'}<${field.actualType || 'String'}>`;
                }
              }
        %>
        @Schema(description = "<%= comment %>")
        private <%- fieldType %> <%= fieldName %>;
        <% }} %>
    }

    @Data
    public static class <%= entityName %>UpdateDTO {
        <% if (hasEmbeddedId) { 
            const idFieldInfo = entitySearchFields.find(f => f.name === ymlConfig.idField); %>
        @Schema(description = "<%= idFieldInfo?.comment || `${entityName} ID` %>")
        @NotNull(message = "ID is required")
        private <%= embeddedIdType %> <%= ymlConfig.idField %>;
        <% } else { 
            const idFieldInfo = entitySearchFields.find(f => f.name === ymlConfig.idField); %>
        @Schema(description = "<%= idFieldInfo?.comment || `${entityName} ID` %>")
        @NotBlank(message = "ID is required")
        private <%= idFieldInfo?.type || idType %> <%= ymlConfig.idField %>;
        <% } %>
        <% for (let field of entityFields) { 
            const ymlField = ymlConfig.fields[field.name];
            if (ymlField?.views?.includes('edit') && field.name !== ymlConfig.idField) { 
              let fieldType = field.type;
              let fieldName = field.name;
              let comment = field.comment ? field.comment.split(':')[0] : ymlField.comment || fieldName;
              
              // 참조 필드인 경우
              if (ymlField?.reference) {
                const collectionType = ymlField.reference.multiple ? 'Set' : null;
                fieldType = collectionType 
                  ? `${collectionType}<${ymlField.reference.idType || 'String'}>`
                  : ymlField.reference.idType || 'String';
                fieldName = ymlField.reference.multiple
                  ? `${ymlField.reference.idField}s`
                  : ymlField.reference.idField;
                comment = `${comment} ID`;
              }
              // 컬렉션 필드인 경우
              else if (field.isCollection) {
                if (field.collectionType === 'Map') {
                  fieldType = field.type;  // Map<String, String> 형태의 원본 타입 사용
                } else {
                  fieldType = `${field.collectionType || 'List'}<${field.actualType || 'String'}>`;
                }
              }
        %>
        @Schema(description = "<%= comment %>")
        private <%- fieldType %> <%= fieldName %>;
        <% }} %>
    }

    @Data
    public static class <%= entityName %>BatchUpdateDTO {
        <% if (hasEmbeddedId) { 
            const idFieldInfo = entitySearchFields.find(f => f.name === ymlConfig.idField); %>
        @Schema(description = "<%= idFieldInfo?.comment || `${entityName} ID` %> list")
        private Set<<%= embeddedIdType %>> <%= ymlConfig.idField %>s;
        <% } else { 
            const idFieldInfo = entitySearchFields.find(f => f.name === ymlConfig.idField); %>
        @Schema(description = "<%= idFieldInfo?.comment || `${entityName} ID` %> list")
        private Set<<%= idFieldInfo?.type || idType %>> <%= ymlConfig.idField %>s;
        <% } %>
        <% for (let field of entityFields) { 
            const ymlField = ymlConfig.fields[field.name];
            if (ymlField?.views?.includes('batchUpdate')) { 
              if (field.name === ymlConfig.idField) {
                continue;
              }
              let fieldType = field.type;
              let fieldName = field.name;
              let comment = field.comment ? field.comment.split(':')[0] : ymlField.comment || fieldName;
              
              // 참조 필드인 경우
              if (ymlField?.reference) {
                const collectionType = ymlField.reference.multiple ? 'Set' : null;
                fieldType = collectionType 
                  ? `${collectionType}<${ymlField.reference.idType || 'String'}>`
                  : ymlField.reference.idType || 'String';
                fieldName = ymlField.reference.multiple
                  ? `${ymlField.reference.idField}s`
                  : ymlField.reference.idField;
                comment = `${comment} ID`;
              }
              // 컬렉션 필드인 경우
              else if (field.isCollection) {
                if (field.collectionType === 'Map') {
                  fieldType = field.type;  // Map<String, String> 형태의 원본 타입 사용
                } else {
                  fieldType = `${field.collectionType || 'List'}<${field.actualType || 'String'}>`;
                }
              }
        %>
        @Schema(description = "<%= comment %>")
        private <%- fieldType %> <%= fieldName %>;
        <% }} %>
    }

    //----------------------------------
    // Projection
    //----------------------------------

    @Data
    public static class <%= entityName %>DetailDTO {
        <% for (let field of entityFields) { 
            const ymlField = ymlConfig.fields[field.name];
            if (ymlField?.views?.includes('detail')) { 
              let fieldType = field.type;
              let fieldName = field.name;
              let comment = field.comment ? field.comment.split(':')[0] : ymlField.comment || fieldName;
        %>
        @Schema(description = "<%= comment %>")
        private <%- fieldType %> <%= fieldName %>;
        <% }} %>
        
        //----------

        @Schema(description = "Created by")
        private String createdBy;

        @Schema(description = "Created at")
        @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm")
        private OffsetDateTime createdAt;

        @Schema(description = "Updated by")
        private String updatedBy;

        @Schema(description = "Updated at")
        @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm")
        private OffsetDateTime updatedAt;
    }

    @Data
    public static class <%= entityName %>ListDTO {
        <% for (let field of entityFields) { 
            const ymlField = ymlConfig.fields[field.name];
            if (ymlField?.views?.includes('list')) { 
              let fieldType = field.type;
              let fieldName = field.name;
              let comment = field.comment ? field.comment.split(':')[0] : ymlField.comment || fieldName;
        %>
        @Schema(description = "<%= comment %>")
        private <%- fieldType %> <%= fieldName %>;
        <% }} %>
        
        //----------
        
        @Schema(description = "Created by")
        private String createdBy;

        @Schema(description = "Created at")
        @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm")
        private OffsetDateTime createdAt;

        @Schema(description = "Updated by")
        private String updatedBy;

        @Schema(description = "Updated at")
        @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm")
        private OffsetDateTime updatedAt;
    }
} 