package <%= packagePaths['service'] %>;

import <%= packagePaths['dto'] %>.<%= entityName %>DTOs.*;
import <%= entityPackage %>.<%= entityName %>;
<% if (hasEmbeddedId) { %>
import <%= entityPackage %>.<%= entityName %>.<%= embeddedIdType %>;
<% } %>
import <%= packagePaths['repository'] %>.<%= entityName %>Repository;
<%
// 참조 엔티티의 import 구문 분석
const importedServices = new Set();
const importedDTOs = new Set();

// 엔티티 필드에서 참조 타입 찾기
fields.forEach(field => {
    if (field.typeKind === 'entity' || field.isRelation || field.relationType === 'ManyToOne') {
        const entityType = field.isCollection ? field.actualType : field.type;
        const entityImport = field.importPath || `${entityPackage}.${entityType}`;
        // domain.module.submodule.entity -> web.module.submodule.service
        const servicePath = entityImport
            .replace('.domain.', '.web.')
            .replace('.entity.', '.')
            .replace(entityType, `service.${entityType}Service`);
        
        if (!importedServices.has(entityType)) {
            importedServices.add(entityType); %>
import <%= servicePath %>;<%
        }
    }
}); %>

import dev.simplecore.simplix.web.service.SimpliXBaseService;
import dev.simplecore.searchable.core.condition.SearchCondition;
import dev.simplecore.searchable.core.condition.parser.SearchableParamsParser;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.data.domain.Page;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.persistence.EntityManager;
import java.util.*;

/**
 * This file was auto-generated by SimpliX Generator
 *
 * Generator Version: <%= generatorVersion %>
 * Generated At: <%= generatedAt %>
 * Generated By: <%= gitUser %><<%= gitEmail %>>
 */

/**
 * Service class for managing <%= entityName %> entities.
 * Provides business logic for CRUD operations, batch processing, and search functionality for <%= entityName %> entities.
<% if (hasEmbeddedId) { %>
 * This entity uses a composite key (<%= embeddedIdType %>).
<% } %>
 */
@Service
@Transactional(readOnly = true)
public class <%= entityName %>Service extends SimpliXBaseService<<%= entityName %>, <%= idType %>> {
    <%
    // Reference service member variables
    const addedServices = new Set();
    fields.forEach(field => {
        const ymlField = ymlConfig.fields?.[field.name];
        if ((field.typeKind === 'entity' || field.isRelation || field.relationType === 'ManyToOne')) {
            const entityType = field.isCollection ? field.actualType : field.type;
            if (!addedServices.has(entityType)) {
                addedServices.add(entityType); %>
    private final ObjectProvider<<%= entityType %>Service> <%= _.camelCase(entityType + 'Service') %>Provider;
    <% }
        }
    }); 
    
    // yml 설정에서 추가 참조 타입 찾기
    if (ymlConfig && ymlConfig.fields) {
        Object.values(ymlConfig.fields).forEach(field => {
            if (field.reference && field.reference.entity && !addedServices.has(field.reference.entity)) {
                addedServices.add(field.reference.entity); %>
    private final ObjectProvider<<%= field.reference.entity %>Service> <%= _.camelCase(field.reference.entity + 'Service') %>Provider;
    <% }
        });
    } %>

    /**
     * Constructs a new <%= entityName %>Service with required dependencies.
     *
     * @param repository The repository for <%= entityName %> entities
     * @param entityManager JPA EntityManager for database operations<%
     Array.from(addedServices).forEach(entity => { %>
     * @param <%= _.camelCase(entity + 'Service') %>Provider Provider for <%= entity %> service<%
     }); %>
     */
    public <%= entityName %>Service(
        <%= entityName %>Repository repository,
        EntityManager entityManager<%
        Array.from(addedServices).forEach(entity => { %>,
        ObjectProvider<<%= entity %>Service> <%= _.camelCase(entity + 'Service') %>Provider<%
        }); %>
    ) {
        super(repository, entityManager);
        <% Array.from(addedServices).forEach(entity => { %>
        this.<%= _.camelCase(entity + 'Service') %>Provider = <%= _.camelCase(entity + 'Service') %>Provider;<%
        }); %>
    }

    /**
     * Creates a new <%= entityName %> entity from the provided DTO.
     *
     * @param createDTO DTO containing the data for the new <%= entityName %>
     * @return <%= entityName %>DetailDTO of the created entity
     * @throws RuntimeException if related entities are not found
     */
    @Transactional
    public <%= entityName %>DetailDTO create(<%= entityName %>CreateDTO createDTO) {
        <%= entityName %> entity = new <%= entityName %>();
        modelMapper.map(createDTO, entity);
        return saveAndGetProjection(entity<% 
        Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
            if (field.reference) {
                const entityField = fields.find(f => f.name === fieldName);
                const isCollection = entityField && (entityField.isCollection || entityField.type?.startsWith('Set<') || entityField.type?.startsWith('List<') || entityField.relationType === 'ManyToMany');
                const referenceFieldName = isCollection ? `${field.reference.idField}s` : field.reference.idField;
                %>, createDTO.get<%= referenceFieldName.charAt(0).toUpperCase() + referenceFieldName.slice(1) %>()<%
            }
        }); %>);
    }

    /**
     * Updates an existing <%= entityName %> entity with the provided DTO data.
     *
     * @param entity The existing <%= entityName %> entity to update
     * @param updateDto DTO containing the updated data
     * @return <%= entityName %>DetailDTO of the updated entity
     * @throws RuntimeException if related entities are not found
     */
    @Transactional
    public <%= entityName %>DetailDTO update(<%= entityName %> entity, <%= entityName %>UpdateDTO updateDto) {
        modelMapper.map(updateDto, entity);
        return saveAndGetProjection(entity<% 
        Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
            if (field.reference) {
                const entityField = fields.find(f => f.name === fieldName);
                const isCollection = entityField && (entityField.isCollection || entityField.type?.startsWith('Set<') || entityField.type?.startsWith('List<') || entityField.relationType === 'ManyToMany');
                const referenceFieldName = isCollection ? `${field.reference.idField}s` : field.reference.idField;
                %>, updateDto.get<%= referenceFieldName.charAt(0).toUpperCase() + referenceFieldName.slice(1) %>()<%
            }
        }); %>);
    }

    /**
     * Deletes a <%= entityName %> entity by its ID.
     *
     * @param <%= ymlConfig.idField %> The ID of the <%= entityName %> to delete
     */
    @Transactional
    public void delete(<%= idType %> <%= ymlConfig.idField %>) {
        deleteById(<%= ymlConfig.idField %>);
    }

    /**
     * Deletes multiple <%= entityName %> entities by their IDs.
     *
     * @param <%= ymlConfig.idField %>s List of <%= entityName %> IDs to delete
     */
    @Transactional
    public void batchDelete(List<<%= idType %>> <%= ymlConfig.idField %>s) {
        deleteAllByIds(<%= ymlConfig.idField %>s);
    }

    /**
     * Searches for <%= entityName %> entities using provided search parameters.
     *
     * @param params Map of search parameters and their values
     * @return Page of <%= entityName %>ListDTO matching the search criteria
     */
    public Page<<%= entityName %>ListDTO> search(Map<String, String> params) {
        SearchCondition<<%= entityName %>SearchDTO> searchCondition =
                new SearchableParamsParser<<%= entityName %>SearchDTO>(<%= entityName %>SearchDTO.class).convert(params);
        return findAllWithSearch(searchCondition, <%= entityName %>ListDTO.class);
    }

    /**
     * Searches for <%= entityName %> entities using a SearchCondition object.
     *
     * @param searchCondition Search conditions for filtering <%= entityName %> entities
     * @return Page of <%= entityName %>ListDTO matching the search criteria
     */
    public Page<<%= entityName %>ListDTO> search(SearchCondition<<%= entityName %>SearchDTO> searchCondition) {
        return findAllWithSearch(searchCondition, <%= entityName %>ListDTO.class);
    }

    /**
     * Updates multiple <%= entityName %> entities in a single operation.
     *
     * @param updateDtos Set of DTOs containing update data for multiple <%= entityName %>s
     * @return List of <%= entityName %>DetailDTO for the updated entities
     * @throws RuntimeException if any related entities are not found
     */
    @Transactional
    public List<<%= entityName %>DetailDTO> multiUpdate(Set<<%= entityName %>UpdateDTO> updateDtos) {
        List<<%= entityName %>DetailDTO> updatedEntities = new ArrayList<>();

        for (<%= entityName %>UpdateDTO updateDto : updateDtos) {
            if (updateDto.get<%= ymlConfig.idField.charAt(0).toUpperCase() + ymlConfig.idField.slice(1) %>() == null) {
                continue;
            }

            Optional<<%= entityName %>> entityOpt = findById(updateDto.get<%= ymlConfig.idField.charAt(0).toUpperCase() + ymlConfig.idField.slice(1) %>());
            if (entityOpt.isPresent()) {
                <%= entityName %> entity = entityOpt.get();
                <%= entityName %>DetailDTO updatedEntity = update(entity, updateDto);
                updatedEntities.add(updatedEntity);
            }
        }

        return updatedEntities;
    }

    /**
     * Performs batch updates on multiple <%= entityName %> entities.
     *
     * @param dto DTO containing the batch update data and target IDs
     * @throws RuntimeException if any related entities are not found
     */
    @Transactional
    public void batchUpdate(<%= entityName %>BatchUpdateDTO dto) {
        <% 
        // batchUpdate가 허용된 필드가 있는지 확인
        const hasBatchUpdateFields = fields.some(field => {
            const ymlField = ymlConfig.fields?.[field.name];
            return ymlField?.views?.includes('batchUpdate');
        });
        
        if (hasBatchUpdateFields) { %>List<<%= entityName %>> entities = findAllById(dto.get<%= ymlConfig.idField.charAt(0).toUpperCase() + ymlConfig.idField.slice(1) %>s());

        if (!entities.isEmpty()) {
            entities.forEach(entity -> {
                <% fields.forEach(field => {
                    // yml 설정에서 batchUpdate가 허용된 필드만 처리
                    const ymlField = ymlConfig.fields?.[field.name];
                    if (!ymlField?.views?.includes('batchUpdate')) return;

                    const upperFieldName = field.name.charAt(0).toUpperCase() + field.name.slice(1);
                    if (field.typeKind === 'entity' || field.isRelation || field.relationType === 'ManyToOne') { 
                        const idFieldName = ymlField.reference.idField;
                        const upperIdFieldName = idFieldName.charAt(0).toUpperCase() + idFieldName.slice(1);
                        if (field.isCollection || field.relationType === 'ManyToMany') { %>
                if (dto.get<%= upperIdFieldName %>s() != null) {
                    <%
                    const collectionImpl = field.collectionType === 'List' ? 'ArrayList' : 'HashSet';
                    const entityType = field.isCollection ? field.actualType : field.type;
                    %>
                    entity.set<%= upperFieldName %>(new <%= collectionImpl %><>(<%= _.camelCase(entityType + 'Service') %>Provider.getIfAvailable().findAllById(dto.get<%= upperIdFieldName %>s())));
                }
                <%      } else { %>
                if (dto.get<%= upperIdFieldName %>() != null) {
                    Objects.requireNonNull(<%= _.camelCase(field.type + 'Service') %>Provider.getIfAvailable()).findById(dto.get<%= upperIdFieldName %>())
                        .ifPresent(entity::set<%= upperFieldName %>);
                }
                <%      }
                    } else { %>
                if (dto.get<%= upperFieldName %>() != null) {
                    entity.set<%= upperFieldName %>(dto.get<%= upperFieldName %>());
                }
                <% }}); %>
            });

            saveAll(entities);
        }<% } %>
    }

    //----------------------------------

    /**
     * Saves a <%= entityName %> entity and returns its projection.
     * Handles the relationships with other entities.
     *
     * @param entity The <%= entityName %> entity to save<%
     Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
         if (field.reference) {
             const idFieldName = field.reference.idField;
             if (field.reference.multiple) { %>
     * @param <%= idFieldName %>s The <%= field.reference.entity %> IDs to set<%
             } else { %>
     * @param <%= idFieldName %> The <%= field.reference.entity %> ID to set<%
             }
         }
     }); %>
     * @return <%= entityName %>DetailDTO of the saved entity
     * @throws RuntimeException if saving fails or if related entities are not found
     */
    private <%= entityName %>DetailDTO saveAndGetProjection(<%= entityName %> entity<% 
    Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
        if (field.reference) {
            const idFieldName = field.reference.idField;
            if (field.reference.multiple) { %>, Set<String> <%= idFieldName %>s<% }
            else { %>, String <%= idFieldName %><% }
        }
    }); 
    %>) {
        <% if (Object.values(ymlConfig.fields || {}).some(f => f.reference)) { %>
        //----------------------------------
        // Many-to-one relationships
        //----------------------------------
        <%
        Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
            if (field.reference && !field.reference.multiple) {
                const serviceVar = _.camelCase(field.reference.entity);
                const idFieldName = field.reference.idField;
        %>
        // <%= field.reference.entity %>
        if (<%= idFieldName %> != null) {
            <%= field.reference.entity %>Service <%= serviceVar %>Service = <%= serviceVar %>ServiceProvider.getIfAvailable();
            if (<%= serviceVar %>Service != null) {
                entity.set<%= fieldName.charAt(0).toUpperCase() + fieldName.slice(1) %>(<%= serviceVar %>Service.findById(<%= idFieldName %>)
                    .orElseThrow(() -> new RuntimeException("<%= field.reference.entity %> not found")));
            }
        }
                <%
            }
        }); %>

        //----------------------------------
        // Many-to-many relationships
        //----------------------------------
        <%
        Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
            if (field.reference && field.reference.multiple) {
                const serviceVar = _.camelCase(field.reference.entity);
                const idFieldName = field.reference.idField;
        %>
        // <%= field.reference.entity %>
        if (<%= idFieldName %>s != null) {
            <%= field.reference.entity %>Service <%= serviceVar %>Service = <%= serviceVar %>ServiceProvider.getIfAvailable();
            if (<%= serviceVar %>Service != null) {
                <%
                const entityField = fields.find(f => f.name === fieldName);
                const collectionImpl = entityField?.collectionType === 'List' ? 'ArrayList' : 'HashSet';
                %>
                entity.set<%= fieldName.charAt(0).toUpperCase() + fieldName.slice(1) %>(new <%= collectionImpl %><>(<%= serviceVar %>Service.findAllById(<%= idFieldName %>s)));
            }
        }
                <%
            }
        }); %>
        <% } %>

        <%= entityName %> savedEntity = saveAndFlush(entity);
        return findById(savedEntity.getId(), <%= entityName %>DetailDTO.class)
            .orElseThrow(() -> new RuntimeException("Failed to retrieve saved entity"));
    }

    //----------------------------------

    /**
     * Checks if the current user has the specified permission for the entity.
     *
     * @param permission The permission to check (e.g., "view", "edit", "delete")
     * @param <%= ymlConfig.idField %> The ID of the entity to check permissions for. Can be null for new entities
     * @param dto The DTO object containing entity data. Used when <%= ymlConfig.idField %> is null
     * @return true if the user has the permission, false otherwise
     * @throws RuntimeException if the entity is not found with the given <%= ymlConfig.idField %>
     */
    @Override
    public boolean hasOwnerPermission(String permission, <%= idType %> <%= ymlConfig.idField %>, Object dto) {
        // TODO must be implemented

        // // Example implementation
        // <%= entityName %> entity = new <%= entityName %>();
        // if (<%= ymlConfig.idField %> != null) {
        //     entity = findById(<%= ymlConfig.idField %>).orElseThrow(() -> new RuntimeException("<%= entityName %> not found"));
        // } else {
        //     modelMapper.map(dto, entity);
        // }

        // Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        // if (Set.of("view", "edit", "delete").contains(permission)) {
        //     return auth.getName().equals(entity.getUsername());
        // }

        throw new UnsupportedOperationException("Unimplemented method 'hasPermission'");
    }
}
