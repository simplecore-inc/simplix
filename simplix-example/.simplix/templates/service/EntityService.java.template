package <%= packagePaths['service'] %>;

import <%= packagePaths['dto'] %>.<%= entityName %>DTOs.*;
import <%= entityPackage %>.<%= entityName %>;
<% if (hasEmbeddedId) { %>
import <%= entityPackage %>.<%= entityName %>.<%= embeddedIdType %>;
<% } %>
import <%= packagePaths['repository'] %>.<%= entityName %>Repository;
<%
// 참조 엔티티의 import 구문 분석
const importedServices = new Set();
const importedDTOs = new Set();

// 엔티티 필드에서 참조 타입 찾기
fields.forEach(field => {
    if (field.typeKind === 'entity' || field.isRelation || field.relationType === 'ManyToOne') {
        const entityImport = field.importPath || `${entityPackage}.${field.type}`;
        const servicePath = `${packagePaths['service']}.${field.type}Service`;
        
        if (!importedServices.has(field.type)) {
            importedServices.add(field.type); %>
import <%= servicePath %>;<%
        }
    }
}); %>

import service.web.dev.simplecore.simplix.SimpliXBaseService;
import com.github.thkwag.searchable.core.condition.SearchCondition;
import com.github.thkwag.searchable.core.condition.parser.SearchableParamsParser;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.data.domain.Page;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.persistence.EntityManager;
import java.util.*;

/**
 * This file was auto-generated by SimpliX Generator
 *
 * Generator Version: <%= generatorVersion %>
 * Generated At: <%= generatedAt %>
 * Generated By: <%= gitUser %><<%= gitEmail %>>
 */

/**
 * Service class for managing <%= entityName %> entities.
 * Provides business logic for CRUD operations, batch processing, and search functionality for <%= entityName %> entities.
<% if (hasEmbeddedId) { %>
 * This entity uses a composite key (<%= embeddedIdType %>).
<% } %>
 */
@Service
@Transactional(readOnly = true)
public class <%= entityName %>Service extends SimpliXBaseService<<%= entityName %>, <%= idType %>> {
    <%
    // Reference service member variables
    for (const field of entityFields) {
        const ymlField = ymlConfig.fields[field.name];
        if (ymlField?.reference) { %>
    private final ObjectProvider<<%= ymlField.reference.entity %>Service> <%= _.camelCase(ymlField.reference.entity + 'Service') %>Provider;
    <% }} %>

    /**
     * Constructs a new <%= entityName %>Service with required dependencies.
     *
     * @param repository The repository for <%= entityName %> entities
     * @param entityManager JPA EntityManager for database operations<%
     for (const field of entityFields) {
         const ymlField = ymlConfig.fields[field.name];
         if (ymlField?.reference) { %>
     * @param <%= _.camelCase(ymlField.reference.entity + 'Service') %>Provider Provider for <%= ymlField.reference.entity %> service<%
         }
     } %>
     */
    public <%= entityName %>Service(
        <%= entityName %>Repository repository,
        EntityManager entityManager<%
        for (const field of entityFields) {
            const ymlField = ymlConfig.fields[field.name];
            if (ymlField?.reference) { %>,
        ObjectProvider<<%= ymlField.reference.entity %>Service> <%= _.camelCase(ymlField.reference.entity + 'Service') %>Provider<%
            }
        } %>
    ) {
        super(repository, entityManager);
        <% for (const field of entityFields) {
            const ymlField = ymlConfig.fields[field.name];
            if (ymlField?.reference) { %>
        this.<%= _.camelCase(ymlField.reference.entity + 'Service') %>Provider = <%= _.camelCase(ymlField.reference.entity + 'Service') %>Provider;<%
            }
        } %>
    }

    /**
     * Creates a new <%= entityName %> entity from the provided DTO.
     *
     * @param createDTO DTO containing the data for the new <%= entityName %>
     * @return <%= entityName %>DetailDTO of the created entity
     * @throws RuntimeException if related entities are not found
     */
    @Transactional
    public <%= entityName %>DetailDTO create(<%= entityName %>CreateDTO createDTO) {
        <%= entityName %> entity = new <%= entityName %>();
        modelMapper.map(createDTO, entity);
        return saveAndGetProjection(entity<% 
        Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
            if (field.reference) {
                %>, createDTO.get<%= fieldName.charAt(0).toUpperCase() + fieldName.slice(1) %>()<%
            }
        }); %>);
    }

    /**
     * Updates an existing <%= entityName %> entity with the provided DTO data.
     *
     * @param entity The existing <%= entityName %> entity to update
     * @param updateDto DTO containing the updated data
     * @return <%= entityName %>DetailDTO of the updated entity
     * @throws RuntimeException if related entities are not found
     */
    @Transactional
    public <%= entityName %>DetailDTO update(<%= entityName %> entity, <%= entityName %>UpdateDTO updateDto) {
        modelMapper.map(updateDto, entity);
        return saveAndGetProjection(entity<% 
        Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
            if (field.reference) {
                %>, updateDto.get<%= fieldName.charAt(0).toUpperCase() + fieldName.slice(1) %>()<%
            }
        }); %>);
    }

    /**
     * Deletes a <%= entityName %> entity by its ID.
     *
     * @param id The ID of the <%= entityName %> to delete
     */
    @Transactional
    public void delete(<%= idType %> id) {
        deleteById(id);
    }

    /**
     * Deletes multiple <%= entityName %> entities by their IDs.
     *
     * @param ids List of <%= entityName %> IDs to delete
     */
    @Transactional
    public void batchDelete(List<<%= idType %>> ids) {
        deleteAllByIds(ids);
    }

    /**
     * Searches for <%= entityName %> entities using provided search parameters.
     *
     * @param params Map of search parameters and their values
     * @return Page of <%= entityName %>ListDTO matching the search criteria
     */
    public Page<<%= entityName %>ListDTO> search(Map<String, String> params) {
        SearchCondition<<%= entityName %>SearchDTO> searchCondition =
                new SearchableParamsParser<<%= entityName %>SearchDTO>(<%= entityName %>SearchDTO.class).convert(params);
        return findAllWithSearch(searchCondition, <%= entityName %>ListDTO.class);
    }

    /**
     * Searches for <%= entityName %> entities using a SearchCondition object.
     *
     * @param searchCondition Search conditions for filtering <%= entityName %> entities
     * @return Page of <%= entityName %>ListDTO matching the search criteria
     */
    public Page<<%= entityName %>ListDTO> search(SearchCondition<<%= entityName %>SearchDTO> searchCondition) {
        return findAllWithSearch(searchCondition, <%= entityName %>ListDTO.class);
    }

    /**
     * Updates multiple <%= entityName %> entities in a single operation.
     *
     * @param updateDtos Set of DTOs containing update data for multiple <%= entityName %>s
     * @return List of <%= entityName %>DetailDTO for the updated entities
     * @throws RuntimeException if any related entities are not found
     */
    @Transactional
    public List<<%= entityName %>DetailDTO> multiUpdate(Set<<%= entityName %>UpdateDTO> updateDtos) {
        List<<%= entityName %>DetailDTO> updatedEntities = new ArrayList<>();

        for (<%= entityName %>UpdateDTO updateDto : updateDtos) {
            if (updateDto.getId() == null) {
                continue;
            }

            Optional<<%= entityName %>> entityOpt = findById(updateDto.getId());
            if (entityOpt.isPresent()) {
                <%= entityName %> entity = entityOpt.get();
                <%= entityName %>DetailDTO updatedEntity = update(entity, updateDto);
                updatedEntities.add(updatedEntity);
            }
        }

        return updatedEntities;
    }

    /**
     * Performs batch updates on multiple <%= entityName %> entities.
     *
     * @param dto DTO containing the batch update data and target IDs
     * @throws RuntimeException if any related entities are not found
     */
    @Transactional
    public void batchUpdate(<%= entityName %>BatchUpdateDTO dto) {
        List<<%= entityName %>> entities = findAllById(dto.getIds());

        entities.forEach(entity -> {
            <% fields.forEach(field => {
                // yml 설정에서 batchUpdate가 허용된 필드만 처리
                const ymlField = ymlConfig.fields?.[field.name];
                if (!ymlField?.views?.includes('batchUpdate')) return;

                const upperFieldName = field.name.charAt(0).toUpperCase() + field.name.slice(1);
                if (field.typeKind === 'entity' || field.isRelation || field.relationType === 'ManyToOne') { 
                    if (field.isCollection || field.relationType === 'ManyToMany') { %>
            if (dto.get<%= upperFieldName %>() != null) {
                entity.set<%= upperFieldName %>(new HashSet<>(
                    Objects.requireNonNull(<%= _.camelCase(field.type + 'Service') %>Provider.getIfAvailable()).findAllByIds(dto.get<%= upperFieldName %>())
                ));
            }
            <%      } else { %>
            if (dto.get<%= upperFieldName %>() != null) {
                Objects.requireNonNull(<%= _.camelCase(field.type + 'Service') %>Provider.getIfAvailable()).findById(dto.get<%= upperFieldName %>())
                    .ifPresent(entity::set<%= upperFieldName %>);
            }
            <%      }
                } else { %>
            if (dto.get<%= upperFieldName %>() != null) {
                entity.set<%= upperFieldName %>(dto.get<%= upperFieldName %>());
            }
            <% }}); %>
        });

        saveAll(entities);
    }

    //----------------------------------

    /**
     * Saves a <%= entityName %> entity and returns its projection.
     * Handles the relationships with other entities.
     *
     * @param entity The <%= entityName %> entity to save
     * @param dto The DTO containing relationship data
     * @return <%= entityName %>DetailDTO of the saved entity
     * @throws RuntimeException if saving fails or if related entities are not found
     */
    private <%= entityName %>DetailDTO saveAndGetProjection(<%= entityName %> entity<% 
    Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
        if (field.reference) {
            if (field.reference.multiple) { %>, Set<String> <%= fieldName %><% }
            else { %>, String <%= fieldName %><% }
        }
    }); 
    %>) {
        <% if (Object.values(ymlConfig.fields || {}).some(f => f.reference)) { %>
        //----------------------------------
        // Many-to-one relationships
        //----------------------------------
        <%
        Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
            if (field.reference && !field.reference.multiple) {
                const serviceVar = _.camelCase(field.reference.entity);
        %>
        // <%= field.reference.entity %>
        if (<%= fieldName %> != null) {
            <%= field.reference.entity %>Service <%= serviceVar %>Service = <%= serviceVar %>ServiceProvider.getIfAvailable();
            if (<%= serviceVar %>Service != null) {
                entity.set<%= fieldName.charAt(0).toUpperCase() + fieldName.slice(1) %>(<%= serviceVar %>Service.findById(<%= fieldName %>)
                    .orElseThrow(() -> new RuntimeException("<%= field.reference.entity %> not found")));
            }
        }
                <%
            }
        }); %>

        //----------------------------------
        // Many-to-many relationships
        //----------------------------------
        <%
        Object.entries(ymlConfig.fields || {}).forEach(([fieldName, field]) => {
            if (field.reference && field.reference.multiple) {
                const serviceVar = _.camelCase(field.reference.entity);
        %>
        // <%= field.reference.entity %>
        if (<%= fieldName %> != null) {
            <%= field.reference.entity %>Service <%= serviceVar %>Service = <%= serviceVar %>ServiceProvider.getIfAvailable();
            if (<%= serviceVar %>Service != null) {
                entity.set<%= fieldName.charAt(0).toUpperCase() + fieldName.slice(1) %>(new HashSet<>(<%= serviceVar %>Service.findAllByIds(<%= fieldName %>)));
            }
        }
                <%
            }
        }); %>
        <% } %>

        <%= entityName %> savedEntity = saveAndFlush(entity);
        return findById(savedEntity.getId(), <%= entityName %>DetailDTO.class)
            .orElseThrow(() -> new RuntimeException("Failed to retrieve saved entity"));
    }

    //----------------------------------

    /**
     * Checks if the current user has the specified permission for the entity.
     *
     * @param permission The permission to check (e.g., "view", "edit", "delete")
     * @param id The ID of the entity to check permissions for. Can be null for new entities
     * @param dto The DTO object containing entity data. Used when id is null
     * @return true if the user has the permission, false otherwise
     * @throws RuntimeException if the entity is not found with the given id
     */
    @Override
    public boolean hasOwnerPermission(String permission, <%= idType %> id, Object dto) {
        // TODO must be implemented

        // // Example implementation
        // <%= entityName %> entity = new <%= entityName %>();
        // if (id != null) {
        //     entity = findById(id).orElseThrow(() -> new RuntimeException("<%= entityName %> not found"));
        // } else {
        //     modelMapper.map(dto, entity);
        // }

        // Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        // if (Set.of("view", "edit", "delete").contains(permission)) {
        //     return auth.getName().equals(entity.getUsername());
        // }

        throw new UnsupportedOperationException("Unimplemented method 'hasPermission'");
    }
}
