package dev.simplecore.simplix.auth.jwe.provider;

import dev.simplecore.simplix.auth.jwe.exception.JweKeyException;
import dev.simplecore.simplix.auth.jwe.store.JweKeyData;
import dev.simplecore.simplix.auth.jwe.store.JweKeyStore;
import dev.simplecore.simplix.encryption.service.EncryptionService;
import lombok.extern.slf4j.Slf4j;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Database-backed JWE key provider with in-memory caching.
 * Uses simplix-encryption for key material encryption at rest.
 *
 * <p>Key Lifecycle:</p>
 * <ol>
 *   <li>Keys are generated by {@link dev.simplecore.simplix.auth.jwe.service.JweKeyRotationService}</li>
 *   <li>Keys are encrypted and stored via {@link JweKeyStore}</li>
 *   <li>DatabaseJweKeyProvider loads, decrypts, and caches keys</li>
 *   <li>Multiple versions are kept for decrypting existing tokens</li>
 * </ol>
 *
 * <p>Thread Safety:</p>
 * <ul>
 *   <li>Key cache uses immutable {@link KeyCacheState} record with copy-on-write pattern</li>
 *   <li>Cache state reference is volatile for visibility across threads</li>
 *   <li>Refresh operations use {@link java.util.concurrent.locks.ReentrantLock} to prevent concurrent refresh</li>
 * </ul>
 *
 * @see JweKeyStore
 * @see dev.simplecore.simplix.auth.jwe.service.JweKeyRotationService
 */
@Slf4j
public class DatabaseJweKeyProvider implements JweKeyProvider {

    private final JweKeyStore keyStore;
    private final EncryptionService encryptionService;

    /**
     * Holder for key cache state. Immutable to enable atomic replacement.
     * Contains both the key map and current version to ensure consistency.
     */
    private record KeyCacheState(Map<String, KeyPair> keys, String currentVersion) {
        KeyCacheState {
            // Defensive copy to ensure immutability
            keys = keys != null ? Map.copyOf(keys) : Map.of();
        }

        KeyPair get(String version) {
            return keys.get(version);
        }

        boolean containsKey(String version) {
            return keys.containsKey(version);
        }

        Set<String> keySet() {
            return keys.keySet();
        }

        int size() {
            return keys.size();
        }

        boolean isEmpty() {
            return keys.isEmpty();
        }
    }

    /**
     * Atomic cache state holder. Uses copy-on-write pattern.
     * Both key map and current version are updated together atomically.
     */
    private volatile KeyCacheState cacheState = new KeyCacheState(Map.of(), null);

    /**
     * Lock for refresh operations to prevent concurrent refresh calls.
     */
    private final ReentrantLock refreshLock = new ReentrantLock();

    private final KeyFactory rsaKeyFactory;

    /**
     * Creates a new DatabaseJweKeyProvider.
     *
     * @param keyStore          Storage implementation for persisted keys
     * @param encryptionService Encryption service for key material decryption
     */
    public DatabaseJweKeyProvider(JweKeyStore keyStore, EncryptionService encryptionService) {
        this.keyStore = keyStore;
        this.encryptionService = encryptionService;

        try {
            this.rsaKeyFactory = KeyFactory.getInstance("RSA");
        } catch (NoSuchAlgorithmException e) {
            throw new JweKeyException("RSA algorithm not available", e);
        }
    }

    /**
     * Initializes the provider by loading all keys from storage.
     * Should be called after dependency injection, typically via @PostConstruct
     * or during bean initialization.
     */
    public void initialize() {
        loadAllKeys();
        KeyCacheState state = cacheState;
        if (state.currentVersion() != null) {
            log.info("DatabaseJweKeyProvider initialized with {} key(s), current version: {}",
                state.size(), state.currentVersion());
        } else {
            log.warn("DatabaseJweKeyProvider initialized but no keys found in storage");
        }
    }

    /**
     * Refreshes the key cache from storage.
     * Call this after key rotation to pick up newly created keys.
     * <p>
     * Thread-safe: Uses ReentrantLock to prevent concurrent refresh operations.
     * Non-blocking for readers: Uses copy-on-write pattern so existing requests
     * continue using the old cache until refresh completes.
     */
    public void refresh() {
        // Prevent concurrent refresh operations
        if (!refreshLock.tryLock()) {
            log.trace("Refresh already in progress, skipping");
            return;
        }
        try {
            loadAllKeys();
            KeyCacheState state = cacheState;
            log.info("DatabaseJweKeyProvider refreshed, {} key(s) loaded, current version: {}",
                state.size(), state.currentVersion());
        } finally {
            refreshLock.unlock();
        }
    }

    @Override
    public KeyPair getCurrentKeyPair() {
        KeyCacheState state = cacheState;
        if (state.currentVersion() == null) {
            throw new JweKeyException("No active JWE key configured. " +
                "Ensure keys are initialized via JweKeyRotationService.");
        }
        return getKeyPair(state.currentVersion());
    }

    @Override
    public KeyPair getKeyPair(String version) {
        // Read state once for consistency within this method
        KeyCacheState state = cacheState;
        KeyPair keyPair = state.get(version);

        if (keyPair == null) {
            // Attempt to load from store (might be newly rotated key)
            keyPair = loadKeyOnDemand(version);
        }

        if (keyPair == null) {
            throw new JweKeyException("JWE key version not found: " + version);
        }

        return keyPair;
    }

    @Override
    public String getCurrentVersion() {
        return cacheState.currentVersion();
    }

    @Override
    public Set<String> getAvailableVersions() {
        return cacheState.keySet();
    }

    @Override
    public boolean isConfigured() {
        KeyCacheState state = cacheState;
        return state.currentVersion() != null && !state.isEmpty();
    }

    @Override
    public String getName() {
        return "DatabaseJweKeyProvider";
    }

    /**
     * Loads all keys from storage into the cache.
     * <p>
     * Uses copy-on-write pattern: builds a new cache map first, then atomically
     * replaces the old cache. This ensures existing requests continue working
     * with the old cache until the new one is ready.
     */
    private void loadAllKeys() {
        // Build new cache without affecting the current one
        Map<String, KeyPair> newCache = new HashMap<>();
        String newCurrentVersion = null;

        List<JweKeyData> allKeys = keyStore.findAll();

        for (JweKeyData keyData : allKeys) {
            try {
                KeyPair keyPair = decryptKeyData(keyData);
                newCache.put(keyData.getVersion(), keyPair);
                if (keyData.isActive()) {
                    newCurrentVersion = keyData.getVersion();
                }
            } catch (Exception e) {
                log.error("Failed to load JWE key version '{}': {}",
                    keyData.getVersion(), e.getMessage());
            }
        }

        // Fallback: if no active key but keys exist, use the most recent
        if (newCurrentVersion == null && !newCache.isEmpty()) {
            newCurrentVersion = newCache.keySet().iterator().next();
            log.warn("No active JWE key found, using first available: {}", newCurrentVersion);
        }

        // Atomic replacement - both map and version are updated together
        this.cacheState = new KeyCacheState(newCache, newCurrentVersion);
    }

    /**
     * Decrypts key material from storage.
     *
     * @param keyData Encrypted key data from storage
     * @return Decrypted KeyPair
     */
    private KeyPair decryptKeyData(JweKeyData keyData) {
        try {
            // Decrypt key material using simplix-encryption
            String publicKeyBase64 = encryptionService.decrypt(keyData.getEncryptedPublicKey());
            String privateKeyBase64 = encryptionService.decrypt(keyData.getEncryptedPrivateKey());

            // Decode Base64 to bytes
            byte[] publicKeyBytes = Base64.getDecoder().decode(publicKeyBase64);
            byte[] privateKeyBytes = Base64.getDecoder().decode(privateKeyBase64);

            // Reconstruct keys from encoded form
            PublicKey publicKey = rsaKeyFactory.generatePublic(
                new X509EncodedKeySpec(publicKeyBytes));
            PrivateKey privateKey = rsaKeyFactory.generatePrivate(
                new PKCS8EncodedKeySpec(privateKeyBytes));

            log.trace("Decrypted JWE key version: {}", keyData.getVersion());
            return new KeyPair(publicKey, privateKey);

        } catch (InvalidKeySpecException e) {
            throw new JweKeyException(
                "Invalid key specification for version: " + keyData.getVersion(), e);
        } catch (Exception e) {
            throw new JweKeyException(
                "Failed to decrypt JWE key version: " + keyData.getVersion(), e);
        }
    }

    /**
     * Loads a single key from storage and adds it to the current cache state.
     * Used for on-demand loading when a key is not found in cache.
     * <p>
     * Note: This creates a new cache state with the additional key.
     * The update is atomic but may occasionally result in redundant loading
     * if multiple threads request the same missing key simultaneously.
     *
     * @param version Key version to load
     * @return KeyPair if found and loaded, null otherwise
     */
    private KeyPair loadKeyOnDemand(String version) {
        return keyStore.findByVersion(version)
            .map(keyData -> {
                KeyPair keyPair = decryptKeyData(keyData);

                // Create new state with additional key (copy-on-write)
                KeyCacheState currentState = this.cacheState;
                Map<String, KeyPair> newKeys = new HashMap<>(currentState.keys());
                newKeys.put(version, keyPair);
                this.cacheState = new KeyCacheState(newKeys, currentState.currentVersion());

                log.trace("Loaded JWE key on-demand: {}", version);
                return keyPair;
            })
            .orElse(null);
    }
}
